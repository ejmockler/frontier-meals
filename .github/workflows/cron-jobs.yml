# Cron Jobs for Frontier Meals
# These workflows trigger the API endpoints that handle scheduled tasks.
# Secrets required in GitHub repo settings:
#   - CRON_SECRET: Shared secret for authenticating cron requests
#   - PRODUCTION_URL: https://frontiermeals.com (or your deployed URL)

name: Scheduled Jobs

on:
  schedule:
    # Issue daily QR codes - 12:00 PM Pacific (20:00 UTC in winter, 19:00 UTC in summer)
    # Using 19:00 UTC to account for PDT
    - cron: '0 19 * * *'
  workflow_dispatch:
    inputs:
      job:
        description: 'Job to run manually'
        required: true
        type: choice
        options:
          - issue-qr
          - check-telegram-links
          - retry-emails
          - cleanup-rate-limits
          - cleanup-expired-tokens
          - cleanup-skip-sessions
          - cleanup-discount-reservations
          - all

env:
  # Production domain - Cloudflare Pages with custom domain
  PRODUCTION_URL: 'https://frontiermeals.com'

jobs:
  # Daily QR Code Issuance - Main job that runs on schedule
  issue-qr:
    name: Issue Daily QR Codes
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event.inputs.job == 'issue-qr' || github.event.inputs.job == 'all'
    steps:
      - name: Trigger QR Issuance
        run: |
          response=$(curl -s -L -w "\n%{http_code}" -X POST "${{ env.PRODUCTION_URL }}/api/cron/issue-qr" \
            -H "Content-Type: application/json" \
            -H "Cron-Secret: ${{ secrets.CRON_SECRET }}")

          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          echo "Response: $body"
          echo "HTTP Status: $http_code"

          if [ "$http_code" != "200" ]; then
            echo "::error::QR issuance failed with status $http_code"
            exit 1
          fi

  # Check Telegram Links - Runs daily after QR issuance
  check-telegram-links:
    name: Check Telegram Link Status
    runs-on: ubuntu-latest
    needs: [issue-qr]
    # Continue even if issue-qr is skipped (manual run)
    if: always() && (github.event_name == 'schedule' || github.event.inputs.job == 'check-telegram-links' || github.event.inputs.job == 'all')
    steps:
      - name: Check Telegram Links
        run: |
          response=$(curl -s -L -w "\n%{http_code}" -X POST "${{ env.PRODUCTION_URL }}/api/cron/check-telegram-links" \
            -H "Content-Type: application/json" \
            -H "Cron-Secret: ${{ secrets.CRON_SECRET }}")

          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          echo "Response: $body"
          echo "HTTP Status: $http_code"

          if [ "$http_code" != "200" ]; then
            echo "::warning::Telegram link check returned status $http_code"
          fi

  # Retry Failed Emails - Runs every 6 hours
  retry-emails:
    name: Retry Failed Emails
    runs-on: ubuntu-latest
    if: github.event.inputs.job == 'retry-emails' || github.event.inputs.job == 'all'
    steps:
      - name: Retry Failed Emails
        run: |
          response=$(curl -s -L -w "\n%{http_code}" -X POST "${{ env.PRODUCTION_URL }}/api/cron/retry-emails" \
            -H "Content-Type: application/json" \
            -H "Cron-Secret: ${{ secrets.CRON_SECRET }}")

          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          echo "Response: $body"
          echo "HTTP Status: $http_code"

  # Cleanup Rate Limits - Runs weekly
  cleanup-rate-limits:
    name: Cleanup Rate Limits
    runs-on: ubuntu-latest
    if: github.event.inputs.job == 'cleanup-rate-limits' || github.event.inputs.job == 'all'
    steps:
      - name: Cleanup Rate Limits
        run: |
          response=$(curl -s -L -w "\n%{http_code}" -X POST "${{ env.PRODUCTION_URL }}/api/cron/cleanup-rate-limits" \
            -H "Content-Type: application/json" \
            -H "Cron-Secret: ${{ secrets.CRON_SECRET }}")

          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          echo "Response: $body"
          echo "HTTP Status: $http_code"

  # Cleanup Expired Tokens - Runs weekly
  cleanup-expired-tokens:
    name: Cleanup Expired Tokens
    runs-on: ubuntu-latest
    if: github.event.inputs.job == 'cleanup-expired-tokens' || github.event.inputs.job == 'all'
    steps:
      - name: Cleanup Expired Tokens
        run: |
          response=$(curl -s -L -w "\n%{http_code}" -X POST "${{ env.PRODUCTION_URL }}/api/cron/cleanup-expired-tokens" \
            -H "Content-Type: application/json" \
            -H "Cron-Secret: ${{ secrets.CRON_SECRET }}")

          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          echo "Response: $body"
          echo "HTTP Status: $http_code"

  # Cleanup Skip Sessions - Runs daily
  cleanup-skip-sessions:
    name: Cleanup Skip Sessions
    runs-on: ubuntu-latest
    if: github.event.inputs.job == 'cleanup-skip-sessions' || github.event.inputs.job == 'all'
    steps:
      - name: Cleanup Skip Sessions
        run: |
          response=$(curl -s -L -w "\n%{http_code}" -X POST "${{ env.PRODUCTION_URL }}/api/cron/cleanup-skip-sessions" \
            -H "Content-Type: application/json" \
            -H "Cron-Secret: ${{ secrets.CRON_SECRET }}")

          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          echo "Response: $body"
          echo "HTTP Status: $http_code"

  # Cleanup Discount Reservations - Runs every 5 minutes (separate workflow)
  cleanup-discount-reservations:
    name: Cleanup Discount Reservations
    runs-on: ubuntu-latest
    if: github.event.inputs.job == 'cleanup-discount-reservations' || github.event.inputs.job == 'all'
    steps:
      - name: Cleanup Discount Reservations
        run: |
          response=$(curl -s -L -w "\n%{http_code}" -X POST "${{ env.PRODUCTION_URL }}/api/cron/cleanup-discount-reservations" \
            -H "Content-Type: application/json" \
            -H "Cron-Secret: ${{ secrets.CRON_SECRET }}")

          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          echo "Response: $body"
          echo "HTTP Status: $http_code"
